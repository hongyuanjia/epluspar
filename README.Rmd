---
output:
  github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
library(epScan)
library(knitr)

# the default output hook
hook_output = knitr::knit_hooks$get('output')
knitr::knit_hooks$set(output = function(x, options) {
  if (!is.null(n <- options$out.lines)) {
    x <- unlist(strsplit(x, '\n', fixed = TRUE))
    if (length(x) > n) {
      # truncate the output
      x <- c(head(x, n), '....', '')
    } else {
      x <- c(x, "")
    }
    x <- paste(x, collapse = '\n') # paste first n lines together
  }
  hook_output(x, options)
})

knitr::opts_knit$set(root.dir = tempdir())
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-",
  out.lines = 20
)

# Make sure the date is shown in English format not Chinese.
invisible(Sys.setlocale(category = "LC_TIME", locale = "en_US.UTF-8"))
```

# epScan
Conduct sensitivity analysis and Bayesian calibration of EnergyPlus models.

[![Travis-CI Build Status](https://api.travis-ci.com/ideas-lab-nus/epScan.svg?token=1LqeFok1d6q5niBF8Hqr&branch=master)](https://travis-ci.com/ideas-lab-nus/epScan)
[![CRAN_Status_Badge](http://www.r-pkg.org/badges/version/epScan)](https://cran.r-project.org/package=epScan)
[![CRAN Download Badge](https://cranlogs.r-pkg.org/badges/epScan)](https://cran.r-project.org/package=epScan)

## Installation

Currently, epScan is not on CRAN. You can install the development version from
GitHub.

```{r gh-installation, eval = FALSE}
# install.packages("remotes")
remotes::install_github("ideas-lab-nus/epScan")
```

# Get started

## Sensitivity Analysis

Create a `SensitivityJob` object:

```{r}
# use an example file from EnergyPlus v8.8 for demonstration here
path_idf <- file.path(eplusr::eplus_config(8.8)$dir, "ExampleFiles", "5Zone_Transformer.idf")
path_epw <- file.path(eplusr::eplus_config(8.8)$dir, "WeatherData", "USA_CA_San.Francisco.Intl.AP.724940_TMY3.epw")

# create a `SensitivityJob` class which inheris from eplusr::ParametricJob class
sen <- sensi_job(path_idf, path_epw)
```

Set sensitivity parameters using `$param()` or `$apply_measure()`.

* Using `$param()`

```{r, eval = FALSE}
# set parameter using similar syntax to `Idf$set()` in eplusr
sen$param(
    # For adding a single object field as parameter
    # Syntax: Object = list(Field = c(Min, Max, Levels))
    `Supply Fan 1` = list(Fan_Total_Efficiency = c(0.1, 1.0, 5)),

    # For adding a class field as parameter
    Material := list(
        Thickness = c(min = 0.01, max = 0.08, levels = 5),
        Conductivity = c(min = 0.01, max = 0.6, levels = 6)
    ),

    # use `.names` to give names to each parameter
    .names = c("efficiency", "thickness", "conducitivy"),

    # See `r` and `grid_jump` in `sensitivity::morris`
    .r = 8, .grid_jump = 1
)
```

* Using `$apply_measure()`

```{r}
# first define a "measure"
my_actions <- function (idf, efficiency, thickness, conducitivy) {
    idf$set(
        `Supply Fan 1` = list(Fan_Total_Efficiency = efficiency),
        Material := list(Thickness = thickness, Conductivity = conducitivy)
    )

    idf
}

# then apply that measure with parameter space definitions as function arguments
sen$apply_measure(my_actions,
    efficiency = c(0.1, 1.0, 5),
    thickness = c(0.01, 0.08, 5),
    conducitivy = c(0.1, 0.6, 6),
    .r = 8, .grid_jump = 1
)
```

Get samples

```{r}
sen$samples()
```

Run simulations and calculate statistic indicators

```{r}
# run simulations in temporary directory
sen$run(dir = tempdir(), echo = FALSE)

# extract output
# here is just am example
eng <- sen$tabular_data(table_name = "site and source energy",
    column_name = "energy per total building area",
    row_name = "total site energy")[, as.numeric(value)]

# calculate sensitivity
(result <- sen$evaluate(eng))

# extract data
attr(result, "data")
```

Plot

```{r get-started, fig.path = "man/figures/"}
# plot
plot(result)
```

## Bayesian Calibration

Create a `BayesCalibJob` object:

```{r}
# use an example file from EnergyPlus v8.8 for demonstration here
path_idf <- file.path(eplusr::eplus_config(8.8)$dir, "ExampleFiles", "RefBldgLargeOfficeNew2004_Chicago.idf")
path_epw <- file.path(eplusr::eplus_config(8.8)$dir, "WeatherData", "USA_CA_San.Francisco.Intl.AP.724940_TMY3.epw")

# create a `SensitivityJob` class which inheris from eplusr::ParametricJob class
bc <- bayes_job(path_idf, path_epw)
```

### Get RDD and MDD

`$read_rdd()` and `$read_mdd()` can be used to get RDD and MDD for current seed
model.

```{r}
(rdd <- bc$read_rdd())
(mdd <- bc$read_mdd())
```

### Setting Input and Output Variables

Input variables and output variables can be set by using `$input()` and
`$output()`, respectively. For `$input()`, only variables listed in RDD are
supported. For `$output()`, variables listed in RDD and MDD are both supported.

By default, they are all empty and `$input()`, `$output()` will return `NULL`.

```{r}
bc$input()
bc$output()
bc$models()
```

You can specify input and output parameters using `RddFile`, `MddFile` and
data.frames.

```{r}
# using RDD and MDD
bc$input(rdd[1:3])
bc$output(mdd[1:3])

# using data.frame
bc$input(eplusr::rdd_to_load(rdd[1:3]))
bc$output(eplusr::mdd_to_load(mdd[1:3]))
```

You can set `append` to `NULL` to remove all existing input and output
parameters.

```{r}
bc$input(append = NULL)
bc$output(append = NULL)
```

You can also directly specify variable names:

```{r}
bc$input(
    name = c(
        "site outdoor air drybulb temperature",
        "site outdoor air relative humidity",
        "site direct solar radiation rate per area",
        "chiller electric power",
        "chiller evaporator inlet temperature",
        "chiller evaporator outlet temperature",
        "chiller evaporator mass flow rate",
        "fan air mass flow rate"
    ),
    reporting_frequency = "hourly"
)
bc$output(
    name = c(
        "Electricity:Building",
        "InteriorLights:Electricity",
        "InteriorEquipment:Electricity",
        "Cooling:Electricity",
        "Heating:Electricity",
        "Heating:Gas",
        "Fans:Electricity"
    ),
    reporting_frequency = "hourly"
)
```

Note that variable cannot be set as both an input and output variable.

```{r, error = TRUE}
bc$output(name = "fan air mass flow rate", reporting_frequency = "hourly")
```

Also, note that input and output variables should have the same reporting
frequency.

```{r, error = TRUE}
bc$output(mdd[1], reporting_frequency = "daily")
```

For `$output()`, both variables in RDD and MDD are supported. However, for
`$input()`, only varaibles in RDD are allowed.

### Adding Parameters to Calibrate

Similarly like `SensitivityJob`, parameters can be added using either `$param()`
or `$apply_measure()`.

Here use `$param()` for demonstration. Basically there are 3 format of defining
a parameter:

* `object = list(field1 = c(min, max), field2 = c(min, max), ...)`

  This is the basic format. `field1` and `field2` in `object` will be added as
  two different parameters, with minimum and maximum value specified as `min`
  and `max`.

* `class := list(field1 = c(min, max), field2 = c(min, max), ...)`

  This is useful when you want to treat `field1` and `field2` in all objects in
  `class` as two differnet parameters. Please note the use of special notion of
  `:=` instead of `=`.

* `.(objects) := list(field1 = c(min, max), field2 = c(min, max), ...)`

  Sometimes you may not want to treat a field in all objects in a class but only
  a subset of objects. You can use a special notation on the left hand side
  `.()`. In the parentheses can be object names or IDs.

```{r}
bc$param(
    ZoneInfiltration_DesignFlowRate := list(flow_per_exterior_surface_area = c(0.0003, 0.001)),
    Lights := list(watts_per_zone_floor_area = c(5, 20)),
    .("Core_bottom People", "Core_mid People", "Core_top People") := list(
      zone_floor_area_per_person = c(5, 15)
    ),
    ElectricEquipment := list(watts_per_zone_floor_area = c(5, 20)),
    `CoolSys1 Chiller 1` = list(reference_cop = c(1, 5)),
    `CoolSys1 Chiller 2` = list(reference_cop = c(1, 5)),
    VAV_1_Fan = list(fan_total_efficiency = c(0.1, 0.9)),
    VAV_2_Fan = list(fan_total_efficiency = c(0.1, 0.9)),
    list(
      VAV_3_Fan = list(fan_total_efficiency = c(0.1, 0.9)),
      VAV_5_Fan = list(fan_total_efficiency = c(0.1, 0.9))
    ),

    .names = c("infil_rate", "lights", "people", "equipment", "chiller1cop",
      "chiller2cop", "fan1eff", "fan2eff", "fan3eff", "fan5eff"
    ),

    .num_sim = 2L
)
```

### Getting Sample Values and Parametric Models

Parameter values can be retrieved using `$samples()`.

```{r}
bc$samples()
```

Generated `Idf`s can be retrieved using `$models()`.

```{r}
names(bc$models())
```

### Run simulations and gather data

`$eplus_run()` runs all parametric models in parallel. Parameter `run_period`
can be given to insert a new `RunPeriod` object. In this case, all existing
`RunPeriod` objects in the seed model will be commented out.

```{r}
bc$eplus_run(dir = tempdir(), run_period = list("example", 1, 1, 1, 7), echo = FALSE)
```

`$data_sim()` returns a `data.table` (when `merge` is `TRUE`) or a list of 2
`data.table` (when `merge` is `FALSE`) which contains the simulated data of
input and output parameters. These data will be stored internally and used
during Bayesian calibration using Stan.

The `resolution` parameter can be used to specify the time resolution of
returned data. Note that input time resolution cannot be smaller than the
reporting frequency, otherwise an error will be issued.

```{r, error = TRUE}
bc$data_sim("1 min")
```

```{r}
bc$data_sim()
```

### Specify Measured Data

`$data_field()` takes a `data.frame` of measured value of output parameters and
returns a list of `data.table`s which contains the measured value of input and
output parameters, and newly measured value of input if applicable.

For input parameters, the values of simulation data for the first case are
directly used as the measured values.

For demonstration, we use the seed model to generate fake measured output data.

```{r}
# clone the seed model
seed <- bc$seed()$clone()
# remove existing RunPeriod objects
seed$RunPeriod <- NULL
# set run period as the same as in `$eplus_run()`
seed$add(RunPeriod = list("test", 1, 1, 1, 7))
seed$SimulationControl$set(
    `Run Simulation for Sizing Periods` = "No",
    `Run Simulation for Weather File Run Periods` = "Yes"
)
# save the model to tempdir
seed$save(tempfile(fileext = ".idf"))
job <- seed$run(path_epw, echo = FALSE)
fan_power <- job$report_data(name = bc$output()$variable_name, wide = TRUE)

bc$data_field(fan_power[, -c("case", "Date/Time")])
```

### Specify Input Data for Stan

`$data_bc()` takes a list of field data and simulated data, and returns a
list that contains data input for Bayesican calibration using the Stan model

* `n`: Number of measured parameter observations.
* `m`: Number of simulated observations.
* `p`: Number of input parameters.
* `q`: Number of calibration parameters.
* `yf`: Data of measured output after z-score standardization using data of
  simulated output.
* `yc`: Data of simulated output after z-score standardization.
* `xf`: Data of measured input after min-max normalization.
* `xc`: Data of simulated input after min-max normalization.
* `tc`: Data of calibration parameters after min-max normalization.

```{r}
str(bc$data_bc())
```

You can also supply your own field data and simulated data and using
`$data_bc()` to construct the input for the Stan model. Input `data_field` and
`data_sim` should have the same structure as the output from `$data_field()` and
`$data_sim()`. If `data_field` and `data_sim` is not specified, the output from
`$data_field()` and `$data_sim()` will be used.

### Get Stan file

You can save the internal Stan code using `$stan_file()`. If no path is
specified, a character vector that contains the stan code will be returned.

```{r, out.lines = 20}
bc$stan_file()
```

### Run Bayesian Calibration Using Stan

You can run Bayesian calibration using Stan using `$stan_run()`.

If `data` argument is not specified, the output of `$data_bc()` is directlyed
used.

```{r, eval = FALSE}
options(mc.cores = parallel::detectCores())
bc$stan_run(iter = 300, chains = 3)
```

You can also use custom data set

```{r, eval = FALSE}
bc$stan_run(data = bc$data_bc(), iter = 300, chains = 3)
```

Instead of using builtin Stan model, you can also provide your own Stan code
using `file` argument.

```{r, eval = FALSE}
bc$stan_run(file = bc$stan_file(tempfile(fileext = ".stan")), iter = 300, chains = 3)
```
