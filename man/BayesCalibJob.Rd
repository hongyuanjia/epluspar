% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bayesian.R
\docType{class}
\name{BayesCalibJob}
\alias{BayesCalibJob}
\title{Conduct Bayesian Calibration on an EnergyPlus Model}
\description{
\code{bayes_job()} takes an IDF and EPW as input and returns a \code{BayesCalibJob},
which provides a prototype of conducting Bayesian calibration of EnergyPlus
model.
}
\section{Usage}{
\preformatted{bc <- bayes_job(idf, epw)
bc$version()
bc$seed()
bc$weather()
bc$read_rdd(update = FALSE)
bc$read_mdd(update = FALSE)
bc$input(key_value = NULL, name = NULL, reporting_frequency = NULL, append = FALSE)
bc$output(key_value = NULL, name = NULL, reporting_frequency = NULL, append = FALSE)
bc$param(..., .names = NULL, .num_sim = 30L)
bc$apply_measure(measure, ..., .num_sim = 30L)
bc$samples()
bc$models()
bc$eplus_run(dir = NULL, run_period = NULL, wait = TRUE, force = FALSE,
             copy_external = FALSE, echo = wait)
bc$data_sim(resolution = NULL, exclude_ddy = TRUE, merge = FALSE, all = FALSE)
bc$data_field(output, new_input = NULL, merge = FALSE, all = FALSE)
bc$data_bc()
bc$stan_run(file = NULL, data = NULL, iter = 2000L, chains = 4L, echo = TRUE,
            mc.cores = parallel::detectCores(), ...)
bc$stan_file(path = NULL)
bc$eplus_kill()
bc$eplus_status()
bc$eplus_output_dir(which = NULL)
bc$eplus_locate_output(which = NULL, suffix = ".err", strict = TRUE)
bc$eplus_errors(which = NULL, info = FALSE)
bc$eplus_report_data_dict(which = NULL)
bc$eplus_report_data(which = NULL, key_value = NULL, name = NULL,
                     year = NULL, tz = "UTC", all = FALSE, wide = FALSE,
                     period = NULL, month = NULL, day = NULL, hour = NULL, minute = NULL,
                     interval = NULL, simulation_days = NULL, day_type = NULL,
                     environment_name = NULL)
bc$eplus_tabular_data(which = NULL, report_name = NULL, report_for = NULL,
                      table_name = NULL, column_name = NULL, row_name = NULL)
bc$eplus_save(dir = NULL, separate = TRUE, copy_external = FALSE)
bc$print()
}
}

\section{Create}{
\preformatted{bc <- bayes_job(idf, epw)
}

When calling \code{bayes_job()}, the objects of classes related in output variable
reporting will be deleted, in order to make sure all input and output
variable specifications can be achieved using \code{Output:Variable} and
\code{Output:Meter}. Classes to be deleted include:
\itemize{
\item \code{Output:Variable}
\item \code{Output:Meter}
\item \code{Output:Meter:MeterFileOnly}
\item \code{Output:Meter:Cumulative}
\item \code{Output:Meter:Cumulative:MeterFileOnly}
\item \code{Meter:Custom}
\item \code{Meter:CustomDecrement}
\item \code{Output:EnvironmentalImpactFactors}
}

\strong{Arguments}
\itemize{
\item \code{idf}: Path to EnergyPlus IDF file or an \code{Idf} object.
\item \code{epw}: Path to EnergyPlus EPW file or an \code{Epw} object.
}
}

\section{Get Seed Model and Weather}{
\preformatted{param$version()
param$seed()
param$weather()
}

\code{$version()} returns the version of input \link{Idf} object.

\code{$seed()} returns the input \link{Idf} object.

\code{$weather()} returns the input \link{Epw} object.
}

\section{Get RDD amd MDD Data of Seed Model}{
\preformatted{param$read_rdd(update = FALSE)
param$read_mdd(update = FALSE)
}

\code{$read_rdd()} and \code{$read_mdd()} silently runs EnergyPlus using input seed
model with design-day-only mode to create \code{.rdd} and \code{.mdd} file and returns
the corresponding \link[eplusr:read_rdd]{RddFile} and
\link[eplusr:read_mdd]{MddFile} object, respectively. The \code{RddFile} and
\code{MddFile} object is stored internally and will be directly returned whenever
you call \code{$read_rdd()} and \code{$read_mdd()} again. You can force to run the
design-day-only simulation again to update the contents by setting \code{update}
to \code{TRUE}.

\code{$read_rdd()} and \code{read_mdd()} is useful when adding input and output
parameters.

\strong{Arguments}
\itemize{
\item \code{update}: Whether to run the design-day-only simulation and parse \code{.rdd}
and \code{.mdd} file again. Default: \code{FALSE}.
}
}

\section{Set Input and Output Parameters}{
\preformatted{bc$input(key_value = NULL, name = NULL, reporting_frequency = NULL, append = FALSE)
bc$output(key_value = NULL, name = NULL, reporting_frequency = NULL, append = FALSE)
}

\code{$input()} and \code{$output()} takes input and output parameter definitions in a
similar pattern as you set output variables in \code{Output:Variable} and
\code{Output:Meter} class and returns a \link[data.table:data.table]{data.table}
containing the information of input and output parameters. For \code{$input()},
only variables in RDD are allowed. For \code{$output()}, both variables in RDD and
MDD are allowd. The returned data.table has 5 columns:
\itemize{
\item \code{index}: Indices of input or output parameters.
\item \code{class}: The class that parameters belong to. Will be either
\code{Output:Variable} or \code{Output:Meter}.
\item \code{key_value}: Key value name for variables.
\item \code{variable_name}: Variable names listed in RDD or MDD.
\item \code{reporting_frequency}: Variable reporting frequency.
}

If calling without any argument, the existing input and output parameters are
directly returned, e.g. \code{bc$input()} and \code{bc$output()}.

You can remove all existing input and output parameter by setting \code{append} to
\code{NULL}, e.g. \code{bc$input(append = NULL)} and \code{bc$output(append = NULL)}.

\code{key_value} accepts 3 different formats:
\itemize{
\item A character vector.
\item An \code{RddFile} or an \code{MddFile} object. They can be retrieved using
\code{$read_rdd()} and \code{$read_mdd()}. In this case, \code{name} argument will be
ignored, as its values are directly taken from variable names in input
\code{RddFile} and \code{MddFile} object. For example:\preformatted{bc$input(bc$read_rdd()[1:5])
bc$output(bc$read_mdd()[1:5])
}
\item A \code{\link[=data.frame]{data.frame()}} with valid format for adding \code{Output:Variable} and
\code{Output:Meter} objects using \link[eplusr:Idf]{Idf$load()}. In this case, \code{name}
argument will be ignored. For example:
}\preformatted{bc$input(eplusr::rdd_to_load(bc$read_rdd()[1:5]))
bc$output(eplusr::mdd_to_load(bc$read_mdd()[1:5]))
}

\strong{Arguments}
\itemize{
\item \code{key_value}: Key value name for variables. If not specified, \code{"*"} are used
for all variables. \code{key_value} can also be an \code{RddFile}, \code{MddFile} or a
\code{\link[=data.frame]{data.frame()}}. Please see description above.
\item \code{name}: Variable names listed in RDD or MDD.
\item \code{reporting_frequency}: Variable reporting frequency for \strong{all} variables.
If \code{NULL}, \code{"Timestep"} are used for all variables. All possible
values: \code{"Detailed"}, \code{"Timestep"}, \code{"Hourly"}, \code{"Daily"}, \code{"Monthly"},
\code{"RunPeriod"}, \code{"Environment"}, and \code{"Annual"}. Default: \code{NULL}.
\item \code{append}: Whether to append input variables at the end of
existing ones. A special value \code{NULL} can be given to remove all existing
parameters. Default: \code{FALSE}.
}
}

\section{Set Parameters}{
\preformatted{bc$param(..., .names = NULL, .num_sim = 30L)
bc$apply_measure(measure, ..., .num_sim = 30L)
bc$samples()
bc$models()
}

There are 2 ways to set calibration parameters in \code{BayesCalibJob} class,
i.e. \code{$param()} and \code{$apply_measure()}.

\code{$param()} takes parameter definitions in list format, which is similar to
\code{$set()} in \link[eplusr:Idf]{eplusr::Idf} class except that each field is not assigned with a
single value, but a numeric vector of length 2, indicating the minimum and
maximum of the parameter. Every list in \code{$param()} should be named with a
valid object name. Object ID can also be used but have to be combined with
prevailing two periods \code{..}, e.g. \code{..10} indicates the object with ID \code{10}.

There is two special syntax in \code{$param()}:
\itemize{
\item \code{class := list(field = value)}: Note the use of \code{:=} instead of \code{=}. The
main difference is that, unlike \code{=}, the left hand side of \code{:=} should be a
valid class name in the seed model. It will treat the specified field of
all objects in specified class to as a single calibration parameter.
\item \code{.(object, object) := list(field = value)}: Simimar like above, but note
the use of \code{.()} in the left hand side. You can put multiple object ID or
names in \code{.()}. It will treat the field of all specified objects to as a
single calibration parameter.
}

For example, the code block below defines 4 calibration parameters:
\itemize{
\item Field \code{Fan Total Efficiency} in object named \code{Supply Fan 1} in class
\code{Fan:VariableVolume} class, with minimum and maximum being 0.1 and 1.0,
respectively.
\item Field \code{Thickness} in all objects in class \code{Material}, with minimum and
maximum being 0.01 and 1.0, respectively.
\item Field \code{Conductivity} in all objects in class \code{Material}, with minimum and
maximum being 0.1 and 0.6, respectively.
\item Field \code{Watts per Zone Floor Area} in objects \code{Light1} and \code{Light2} in class
\code{Lights}, with minimum and maximum being 10 and 30, respectively.
}\preformatted{bc$param(
    `Supply Fan 1` = list(Fan_Total_Efficiency = c(min = 0.1, max = 1.0)),
    Material := list(Thickness = c(0.01, 1), Conductivity = c(0.1, 0.6)),
   .("Light1", "Light2") := list(Watts_per_Zone_Floor_Area = c(10, 30))
)
}

\strong{Arguments}
\itemize{
\item \code{...}: Lists of paramter definitions. Each list should be named with a valid
object name or a valid object ID denoted in style \code{..1}, \code{..2} and etc. For
specifying the fields for all objects in a class, the class name instead of
the object name should be used, and a special notation \code{:=} should be used
instead of \code{=}, e.g. \code{class := list(field = value)}. For grouping fields
from different objects in the same class, use \code{.()} in the left hand side
and put object ID or names inside., .e.g \code{.(object1, object2) := list(field = value)}.
\item \code{.num_sim}: An positive integer specifying the number of simulations to run
for each combination of calibration parameter value. Default:
\code{30L}.
\item \code{.names}: A character vector of the parameter names. If \code{NULL},
the parameter will be named in format \code{t + number}. Default: \code{NULL}.
}

\code{$apply_measure()} works in a similar way as the \code{$apply_measure} in
\link[eplusr:ParametricJob]{eplusr::ParametricJob} class, with only exception that each argument
supplied in \code{...} should be a numeric vector of length 2, indicating the
minimum and maximum of the calibration parameter.
Basically \code{$apply_measure()} allows to apply a measure to an \link{Idf}.
A measure here is just a function that takes an \link{Idf} object and other
arguments as input, and returns a modified \link{Idf} object as output. The names
of function parameter will be used as the names of calibration parameter. For
example, the equivalent version of specifying parameters described above
using \code{$apply_measure()} can be:\preformatted{measure <- function (idf, efficiency, thickness, conducitivy, lpd) {
    idf$set(
        `Supply Fan 1` = list(Fan_Total_Efficiency = efficiency),
        Material := list(Thickness = thickness, Conductivity = conducivity)
        .("Light1", "Light2") := list(Watts_per_Zone_Floor_Area = lpd)
    )

    idf
}

bc$apply_measure(measure,
    efficiency = c(min = 0.1, max = 1.0),
    thickness = c(0.01, 1), conductivity = c(0.1, 0.6),
    lpd = c(10, 30)
)
}

\strong{Arguments}
\itemize{
\item \code{measure}: A function that takes an \code{Idf} and other arguments as input and
returns an \code{Idf} object as output.
\item \code{...}: Arguments \strong{except first \code{Idf} argument} that are passed to that
\code{measure}.
\item \code{.num_sim}: An positive integer specifying the number of simulations to run
for each value of calibration parameter value. (NOT CORRECT). Default:
\code{30L}.
}

All models created using \code{$param()} and \code{$apply_measure()} will be named in
the same pattern, i.e. \code{Case_ParameterName(ParamterValue)...}. Note that only
paramter names will be abbreviated using \code{\link[=abbreviate]{abbreviate()}} with \code{minlength}
being \code{5L} and \code{use.classes} being \code{TRUE}. If samples contain duplications,
\code{\link[=make.unique]{make.unique()}} will be called to make sure every model has a unique name.

\code{$samples()} returns a \link[data.table:data.table]{data.table} which contains
the sampled value for each parameter using \link[lhs:randomLHS]{Random Latin Hypercube Sampling} method. The returned data.table has \code{1 + n}
columns, where \code{n} is the parameter number, and \code{1} indicates an extra column
named \code{case} giving the index of each sample. Note that if \code{$samples()} is
called before input and output parameters being set using \code{$input()} and
\code{$output()}, only the sampling will be performed and no parametric models
will be created. This is because information of input and output parameters
are needed in order to make sure that corresponding variables will be
reported during simulations. In this case, you can use \code{$models()} to create
those models.

\code{$models()} returns a list of parametric \link[eplusr:Idf]{Idf} objects created
using calibration parameter values genereated using Random Latin Hypercube
Sampling. As stated above, parametric models can only be created after input,
output and calibration parameters have all be set using \code{$input()},
\code{$output()} and \code{$param()} (or \code{$apply_measure()}), respectively.

All models will be named in the same pattern, i.e.
\code{Case_ParameterName(ParamterValue)...}. Note that paramter names will be
abbreviated using \code{\link[=abbreviate]{abbreviate()}} with \code{minlength} being \code{5L} and
\code{use.classes} being \code{TRUE}.
}

\section{Run Parametric Simulations}{
\preformatted{bc$eplus_run(dir = NULL, run_period = NULL, wait = TRUE, force = FALSE,
             copy_external = FALSE, echo = wait)
}

\code{$eplus_run()} runs all parametric models in parallel. Parameter \code{run_period}
can be given to insert a new \code{RunPeriod} object. In this case, all existing
\code{RunPeriod} objects in the seed model will be commented out.

Note that when \code{run_period} is given, value of field \code{Run Simulation for Weather File Run Periods} in \code{SimulationControl} class will be reset to \code{Yes}
to make sure input run period can take effect.

\strong{Arguments}
\itemize{
\item \code{dir}: The parent output directory for specified simulations. Outputs of
each simulation are placed in a separate folder under the parent directory.
If \code{NULL}, directory of seed model will be used. Default: \code{NULL}.
\item \code{run_period}: A list giving a new \code{RunPeriod} object definition. If not
\code{NULL}, only this new RunPeriod will take effect with all existing
RunPeriod objects in the seed model being commented out. If \code{NULL},
existing run period in the seed model will be used. Default: \code{NULL}.
\item \code{wait}: If \code{TRUE}, R will hang on and wait all EnergyPlus simulations
finish. If \code{FALSE}, all EnergyPlus simulations are run in the background.
Default: \code{TRUE}.
\item \code{force}: Only applicable when the last simulation runs with \code{wait} equals
to \code{FALSE} and is still running. If \code{TRUE}, current running job is
forced to stop and a new one will start. Default: \code{FALSE}.
\item \code{copy_external}: If \code{TRUE}, the external files that every \code{Idf} object
depends on will also be copied into the simulation output directory. The
values of file paths in the Idf will be changed automatically. Currently,
only \code{Schedule:File} class is supported.  This ensures that the output
directory will have all files needed for the model to run. Default is
\code{FALSE}.
\item \code{echo}: Only applicable when \code{wait} is \code{TRUE}. Whether to print simulation
status. Default: the value of \code{wait}.
}
}

\section{Collect Simulation Data}{
\preformatted{bc$data_sim(resolution = NULL, exclude_ddy = TRUE, merge = FALSE, all = FALSE)
}

\code{$data_sim()} returns a \link[data.table:data.table]{data.table} (when \code{merge}
is \code{TRUE}) or a list of 2 \link[data.table:data.table]{data.table} (when
\code{merge} is \code{FALSE}) which contains the simulated data of input and output
parameters. These data will be stored internally and used during Bayesian
calibration using Stan.

The \code{resolution} parameter can be used to specify the time resolution of
returned data. Note that input time resolution cannot be smaller than the
reporting frequency, otherwise an error will be issued.

The parameter is named in the same way as standard EnergyPlus csv output
file, i.e. \code{KeyValue:VariableName[Unit](Frequency)}.

By default, \code{$data_sim()} returns minimal columns, i.e. the \code{Date/Time}
column together with all input and output parameters are returned. You can
retrieve extra columns by setting \code{all} to \code{TRUE}. Those column include:
\itemize{
\item \code{case}: Character type. Same as the parametric model name in pattern
\code{Case_ParameterName(ParamterValue)...}.
\item \code{environment_period_index}: Integer type. The indice of environment.
\item \code{environment_name}: Character type. A text string identifying the
simulation environment.
\item \code{simulation_days}: Integer type. Day of simulation.
\item \code{datetime}: DateTime type. The date time of simulation result. Note that
the year valueas are automatically calculated to meets the start day of
week restriction for each simulation environment.
\item \code{month}: Integer type. The month of reported date time.
\item \code{day}: Integer type. The day of month of reported date time.
\item \code{hour}: Integer type. The hour of reported date time.
\item \code{minute}: Integer type. The minute of reported date time.
\item \code{day_type}: Character type. The type of day, e.g. \code{Monday}, \code{Tuesday} and
etc. Note that \code{day_type} will always be \code{NA} if \code{resolution} is specified.
}

\strong{Arguments}
\itemize{
\item \code{resolution}: A character string specifying a time unit or a multiple of a
unit to change the time resolution of returned simulation data. Valid base
units are \code{min}, \code{hour}, \code{day}, \code{week}, \code{month}, and \code{year}.
Example: \code{10 mins}, \code{2 hours}, \code{1 day}. If \code{NULL}, the variable reporting
frequency is used. Default: \code{NULL}.
\item \code{exclude_ddy}: Whether to exclude design day data. Default: \code{TRUE}.
\item \code{merge}: Whether to merge simulated data of input and output parameters. If
\code{TRUE}, a \link[data.table:data.table]{data.table} is returned which contains
datetime, data of output parameters, and then data of input parameters. If
\code{FALSE}, a list will be returned of which \code{input} contains the data of
input parameters, and \code{output} contains the data of output parameters.
Default: \code{FALSE}.
\item \code{all}: If \code{TRUE}, extra columns are also included in the returned
\link[data.table:data.table]{data.table} describing the simulation case and
datetime components. Default: \code{FALSE}.
}
}

\section{Specify Measured Data}{
\preformatted{bc$data_field(output, new_input = NULL, merge = FALSE, all = FALSE)
}

\code{$data_field()} takes a \code{\link[=data.frame]{data.frame()}} of measured value of output
parameters and returns a list of \link[data.table:data.table]{data.table}s
which contains the measured value of input and output parameters, and newly
measured value of input if applicable.

The specified \code{output} \code{\link[=data.frame]{data.frame()}} is validated using criteria below:
\itemize{
\item The column number should be the same as the number of output specified in
\code{$output()}.
\item The row number should be the same as the number of simulated values for
each case extracted using \code{$data_sim()}.
}

For input parameters, the values of simulation data for the first case are
directly used as the measured values.

Parameter \code{new_input} can be used to give a \code{\link[=data.frame]{data.frame()}} of newly measured
value of input parameters. The column number of input \code{\link[=data.frame]{data.frame()}} should
be the same as the number of input parameters specified in \code{$input()}. If not
specified, the measured values of input parameters will be used for
predictions.

All the data will be stored internally and used during Bayesian calibration
using Stan.

Note that as \code{$data_field()} relies on the output of \code{$data_sim()} to
perform validation on the specified data, \code{$data_field()} cannot be called
before \code{$data_sim()} and internally stored data will be removed whenever
\code{$data_sim()} is called. This aims to make sure that simulated data and field
data can be matched whenever the calibration is performed.

\strong{Arguments}
\itemize{
\item \code{output}: A \code{\link[=data.frame]{data.frame()}} containing measured value of output parameters.
\item \code{new_input}: A \code{\link[=data.frame]{data.frame()}} containing newly measured value of input
parameters.
\item \code{merge}: Whether to merge simulated data of input and output parameters. If
\code{TRUE}, a list of 2 \link[data.table:data.table]{data.table} is returned with
first element named \code{merged} which contains datetime, data of output
parameters, and then data of input parameters, and second element named
\code{new_input} which contains formatted newly measured input parameter values.
If \code{FALSE}, a list of 3 \link[data.table:data.table]{data.table} is returned
with element \code{input}, \code{output} and \code{new_input} containing the data of
input, output parameters and newly measured value of input pamameters.
Default: \code{FALSE}.
\item \code{all}: If \code{TRUE}, extra columns are also included in the returned
\link[data.table:data.table]{data.table} describing the simulation case and
datetime components. For details, please see \code{$data_sim()}. Default:
\code{FALSE}.
}
}

\section{Run Bayesian Calibration Using Stan}{
\preformatted{bc$data_bc()
bc$stan_run(file = NULL, data = NULL, iter = 2000L, chains = 4L, echo = TRUE,
            mc.cores = parallel::detectCores(), ...)
bc$stan_file(path = NULL)
}

\code{$data_bc()} returns a list that contains data input for Bayesican
calibration using the Stan model from Chong (2018):
\itemize{
\item \code{n}: Number of measured parameter observations.
\item \code{n_pred}: Number of newly design points for predictions.
\item \code{m}: Number of simulated observations.
\item \code{p}: Number of input parameters.
\item \code{q}: Number of calibration parameters.
\item \code{y}: Data of measured output after z-score standardization using data of
simulated output.
\item \code{eta}: Data of simulated output after z-score standardization.
\item \code{xf}: Data of measured input after min-max normalization.
\item \code{xc}: Data of simulated input after min-max normalization.
\item \code{x_pred}: Data of new design points for predictions after min-max
normalization.
\item \code{tc}: Data of calibration parameters after min-max normalization.
}

\code{$stan_run()} runs Bayesian calibration using \link[rstan:stan]{Stan} and
returns a list of 2 elements:
\itemize{
\item \code{fit}: An object of S4 class \link[rstan:stanfit]{rstan::stanfit}.
\item \code{y_pred}: A \link[data.table:data.table]{data.table} with predicted output
values.
}

\code{$stan_file()} saves the Stan file used internally for Bayesican calibration.
If no path is given, a character vector of the Stan code is returned. If
given, the code will be save to the path and the file path is returned.

\strong{Arguments}
\itemize{
\item \code{file}: The path to the Stan program to use. If \code{NULL}, the pre-compiled
Stan code from Chong (2018) will be used. Default: \code{NULL}.
\item \code{data}: Only applicable when \code{file} is not \code{NULL}. The data to be used for
Bayesican calibration. If \code{NULL}, the data that \code{$data_bc()} returns is
used. Default: \code{NULL}.
\item \code{path}: A path to save the Stan code. If \code{NULL}, a character vector of the
Stan code is returned.
\item \code{iter}: A positive integer specifying the number of iterations for each
chain (including warmup). Default: \code{2000}.
\item \code{chains}: A positive integer specifying the number of Markov chains.
Default: \code{4}.
\item \code{echo}: Whether to print intermediate output from Stan on the console,
which might be helpful for model debugging. Default: \code{TRUE}.
\item \code{mc.cores}: An integer specifying how many cores to be used for Stan.
Default: \code{parallel::detectCores()}.
\item \code{...}: Additional arguments to pass to \link[rstan:sampling]{rstan::sampling} (when \code{file} is
\code{NULL}) or \link[rstan:stan]{rstan::stan} (when \code{file} is not \code{NULL}).
}
}

\section{Inherited Methods from \code{ParametricJob}}{
\preformatted{bc$eplus_kill()
bc$eplus_status()
bc$eplus_output_dir(which = NULL)
bc$eplus_locate_output(which = NULL, suffix = ".err", strict = TRUE)
bc$eplus_errors(which = NULL, info = FALSE)
bc$eplus_report_data_dict(which = NULL)
bc$eplus_report_data(which = NULL, key_value = NULL, name = NULL,
                     year = NULL, tz = "UTC", all = FALSE, wide = FALSE,
                     period = NULL, month = NULL, day = NULL, hour = NULL, minute = NULL,
                     interval = NULL, simulation_days = NULL, day_type = NULL,
                     environment_name = NULL)
bc$eplus_tabular_data(which = NULL, report_name = NULL, report_for = NULL,
                      table_name = NULL, column_name = NULL, row_name = NULL)
bc$eplus_save(dir = NULL, separate = TRUE, copy_external = FALSE)
}

All methods listed above are inherited from eplusr's
\code{\link[eplusr:ParametricJob]{ParametricJob}}. Each method has been renamed with a
prefix \code{eplus_}, e.g. \code{$output_dir()} in \link[eplusr:ParametricJob]{eplusr::ParametricJob} becomes
\code{$eplus_output_dir()}. For detailed documentation on each
method, please see \link[eplusr:ParametricJob]{eplusr's documentation}.
}

\examples{
\dontrun{
if (eplusr::is_avail_eplus(8.8)) {
    idf_name <- "5Zone_Transformer.idf"
    epw_name <-  "USA_CA_San.Francisco.Intl.AP.724940_TMY3.epw"

    idf_path <- file.path(eplusr::eplus_config(8.8)$dir, "ExampleFiles", idf_name)
    epw_path <- file.path(eplusr::eplus_config(8.8)$dir, "WeatherData", epw_name)

    # create from local files
    bayes_job(idf_path, epw_path)

    # create from an Idf and an Epw object
    bc <- bayes_job(read_idf(idf_path), read_epw(epw_path))

    # get the seed model
    bc$seed()

    # get the weather
    bc$weather()

    # read rdd
    bc$read_rdd()

    # read mdd
    bc$read_mdd()

    # set input and output parameters
    bc$input(name = "fan air mass flow rate", reporting_frequency = "hourly")
    # set input parameters
    bc$output(name = "fan electric power", reporting_frequency = "hourly")

    # get existing input and output
    bc$input()
    bc$output()

    # set sensitivity parameters using $param()
    bc$param(`Supply Fan 1` = list(Fan_Total_Efficiency = c(min = 0.1, max = 1.0)),
        .names = "faneff", .num_sim = 2
    )

    # extract samples
    bc$samples()

    # extract all models
    bc$models()

    # run parametric simulations
    bc$eplus_run(dir = tempdir(), run_period = list("example", 1, 1, 1, 31))

    # print simulation errors
    bc$eplus_errors()

    # extract simulation data
    bc$data_sim()

    # specify field data
    # here use the seed model as an example
    ## clone the seed model
    seed <- bc$seed()$clone()
    ## remove existing RunPeriod objects
    seed$RunPeriod <- NULL
    ## set run period as the same as in `$eplus_run()`
    seed$add(RunPeriod = list("test", 1, 1, 1, 31))
    ## save the model to tempdir
    seed$save(tempfile(fileext = ".idf"))
    job <- seed$run(epw_path, echo = FALSE)
    fan_power <- job$report_data(name = bc$output()$variable_name, wide = TRUE)
    bc$data_field(fan_power[, -c("case", "Date/Time")])

    # run stan
    fit <- bc$stan_run()
}
}
}
\references{
A. Chong and K. Menberg, "Guidelines for the Bayesian calibration of building
energy models", Energy and Buildings, vol. 174, pp. 527–547. DOI:
10.1016/j.enbuild.2018.06.028
}
\author{
Hongyuan Jia, Adrian Chong
}
